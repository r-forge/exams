---
layout: page
#
# Content
#
title: "Stresstest Exercise"
teaser: "Stresstest an exercises to check the correct behavior."
categories:
  - tutorials
tags:
  - Rmd
  - Rnw
  - Markdown
  - LaTeX
  - exams_skeleton
author: umlauf

#
# Style
#
image:
  # shown on top of blog post
  title: laptop_on_table_deriv2.title.jpg
  # preview in list of posts
  thumb: template.150.svg
  # shown on landing page
  # homepage:
  # shown under image on top of blog post
  caption: "R/exams photo (CC-BY)."
---

## Overview

After an dynamic exercise has been developed, it is useful to subject it to a detailed
test. Therefore, the exams package provides the function `stresstest_exercise()`. The function takes
the exercise and compiles it, e.g., 1000 times. In each of the 1000 iterations the correct
solution(s), the run-times, as well as all length one numeric, integer or character objects are
stored in a data frame. The data frame can then be used to examine undesirable behavior of the 
exercise. More specifically, for some values of the objects (parameters) that are created by the 
exercise it might happen that, e.g., calculated solutions are always close to zero, only the largest/
smallest possible solution is correct in a single-choice exercise (e.g., when transforming numeric 
exercises to single-choice), the position of correct answers of single-choice or multiple-choice 
exercises are not equally distributed in general, run-times become increasingly large, exercises 
cannot compile because of an error, etc. From our experience these problems occur quite often in 
practice, therefore, we suggest to always stress-test exercises. 

## Example numeric

In order to exemplify the work flow, let's begin with a simple numeric exercise. The exercise is
about calculating the probability of successfully catching fish in a lake at least `k` times when
trying for `2` or more days. The exercise is provided in the file
[stresstest_exercise-01.Rnw](2017-11-30-stresstest_exercise/2017-11-30-stresstest_exercise-01.Rnw){target="_blank"}.
The dynamic R code for calculating the probability is as follows:

```{r, eval=FALSE}
## sample the probability of success
prob <- sample(seq(0, 0.05, by = 0.01), size = 1)

## sample the number of fishing days
size <- sample(6:20, size = 1)

## sample the number of successful fishing days
k <- sample(2:3, size = 1)

## compute the correct solution in percent
sol <- pbinom(k, size = size, prob = prob) * 100
```
Let's stress-test this exercise 100 times.
```{r, eval=TRUE, results="hide", echo=FALSE}
library("exams")
dir.create(tdir <- tempfile())
file.copy("2017-11-30-stresstest_exercise/2017-11-30-stresstest_exercise-01.Rnw",
  file.path(tdir, "stresstest_exercise-01.Rnw"))
file.copy("2017-11-30-stresstest_exercise/2017-11-30-stresstest_exercise-02.Rnw",
  file.path(tdir, "stresstest_exercise-02.Rnw"))
file.copy("2017-11-30-stresstest_exercise/2017-11-30-stresstest_exercise-03.Rnw",
  file.path(tdir, "stresstest_exercise-03.Rnw"))
file.copy("2017-11-30-stresstest_exercise/2017-11-30-stresstest_exercise-04.Rnw",
  file.path(tdir, "stresstest_exercise-04.Rnw"))
knitr::opts_knit$set("root.dir" = tdir)
set.seed(111)
```
```{r, eval=TRUE}
t1 <- stresstest_exercise("stresstest_exercise-01.Rnw", n = 100)
```

The function compiles the exercise 100 times. During runtime the seed that is used in each iteration
is printed in the R console (seperated by `/`). This way, it is easy to reproduce errors that might
occur when running the stress-test, i.e., just set the seed (see `?set.seed`) with the last number
shown in the console and try to compile the exercise, for example using `exams2html()`, to reproduce
the error.

Here, no errors occurred, however, it is recommended to extensively stress-test exercises, e.g.,
setting the number of iterations `n = 1000` or even higher. Especially when developing more complex
dynamic exercises, it is not uncommon that errors occur after 900 iterations.

To further examine the properties of the exercise the created stress-test object `t1` can be plotted.
```{r, eval=TRUE}
plot(t1)
```

The left panel shows the run-times for each iteration of the stress-test. In this case, the plot
indicates that the exercise compiles efficiently and no further speed improvements need to be
done. The right panel shows the distribution of the numeric solutions. Clearly, by construction of
the exercise most solutions are above 92%, moreover, most solutions are exactly 100%. The careful
reader might already have spotted the problem in the R code above. The sampled probabilities
for success are quite small, therefore, the probability of being successful at least `0` times
is already about 63% if the probability of catching a fish is 5%. Even more critical is the fact
that success probabilities are sampled from 0.00 to 0.05, that is the reason why many solutions
are exactly 100%.

Therefore, the success probabilities could be increased in this example, e.g., by
```{r, eval=TRUE}
prob <- sample(seq(0.1, 0.5, by = 0.01), size = 1)
```

the updated version of the exercise is provided in the file
[stresstest_exercise-02.Rnw](2017-11-30-stresstest_exercise/2017-11-30-stresstest_exercise-02.Rnw){target="_blank"}.
When rerunning the stress-test
```{r, eval=TRUE, results="hide", echo=FALSE}
knitr::opts_knit$set("root.dir" = tdir)
```
```{r, eval=TRUE}
t2 <- stresstest_exercise("stresstest_exercise-02.Rnw", n = 100)
plot(t2)
```

The generated numeric solutions are now much more uniformly distributed.

To better identify which objects created by the exercise are causing undesired values
of the numeric solutions we can plot these against each other with
```{r, eval=FALSE}
plot(t2, type = "solution", variables = c("size", "k"))
```
```{r, eval=TRUE, results="hide", echo=FALSE}
par(mfrow = c(1, 2))
plot(t2, type = "solution", variables = c("size", "k"), ask = FALSE, spar = FALSE)
```

Note that function `stresstest_exercise()` only stores exercise objects of length 1 in a
`data.frame` object named `"objects"`.


## Example schoice

These types of exercise diagnostics are usually even more important when developing choice type
questions, e.g., although the position of the correct answer(s) is shuffled it can easily happen
that for certain values of the exercise objects always the same type of answer, the largest/smallest
possible answer, etc., is correct.

To give an example how to identify these problems using `stresstest_exercise()` we
transform the second version of the exercise into a schoice type question in a very naive way,
see file [stresstest_exercise-03.Rnw](2017-11-30-stresstest_exercise/2017-11-30-stresstest_exercise-03.Rnw){target="_blank"}.
The R code of the exercise is
```{r, eval=FALSE}
## sample the probability of success
prob <- sample(seq(0.1, 0.5, by = 0.01), size = 1)

## sample the number of fishing days
size <- sample(6:20, size = 1)

## sample the number of successful fishing days
k <- sample(2:3, size = 1)

## compute the correct solution in percent
sol <- pbinom(k, size = size, prob = prob) * 100

## some not so good wrong answers
wrong <- sol * runif(3, 0.1, 0.8)

## Transform to single choice.
sol <- formatC(c(sol, wrong), digits = 2, width = 4, flag = "0")
```

and run the stresstest
```{r, eval=TRUE}
t3 <- stresstest_exercise("stresstest_exercise-03.Rnw", n = 100)
plot(t3)
```

In this example the wrong answers are generated by a random proportion of the correct numeric
solution, i.e., the wrong answers are always smaller. This can immediately be seen in the plot of
the solution order frequencies, where the number 1 represents the largest possible numeric
solution and 5 the smallest, respectively. Since the only correct solution is the largest one,
we only see one bar in this image indicating that we really should provide some better wrong
answers when transforming this numeric exercise into a schoice.

A simple solution is provided by the function `num_to_schoice()`, which takes care about these issues.
However, in a lot of cases clever wrong solutions should be generated and in our experience these
are very likely to encounter such problems.

To round this example up we improve the wrong answers by using the default setup of function
`num_to_schoice()`, see file [stresstest_exercise-04.Rnw](2017-11-30-stresstest_exercise/2017-11-30-stresstest_exercise-04.Rnw){target="_blank"}. The slightly modified R code is
```{r, eval=FALSE}
## sample the probability of success
prob <- sample(seq(0.1, 0.5, by = 0.01), size = 1)

## sample the number of fishing days
size <- sample(6:20, size = 1)

## sample the number of successful fishing days
k <- sample(2:3, size = 1)

## compute the correct solution in percent
sol <- pbinom(k, size = size, prob = prob) * 100

## Transform to single choice.
sc <- num_to_schoice(sol, digits = 2, range = c(0, 100), delta = 0.01)
```

and again run the stresstest
```{r, eval=TRUE}
t4 <- stresstest_exercise("stresstest_exercise-04.Rnw", n = 100)
plot(t4)
```

Now, the plot of the solution order frequencies indicates that the correct solution is
not always the largest, the height of the bars is relatively equal in this case.


## Summary

When developing exercises with dynamic R code it is especially important to first check if the
exercises compile into different output formats (e.g., using `exams2pdf()` and `exams2html()`).

The next step should always be to compile exercises a large number of time, e.g., 1000 times
using function `stresstest_exercise()`. If this check runs smoothly, the last step is to examine
the output of the stresstests using the implemented plot method.

If the exercises pass these tests it is very unlikely that problems will occur during your
exams.

