<<echo=FALSE, results=hide>>=
library("zoo")

decplot <- function(x, factor = 0.95,
  main = NULL, ylim = NULL, cex.lab = 1.5, xlab = "", ...)
{
  if(is.null(main)) main <- paste("Decomposition of", x$type, "time series")

  yr <- range(x$random, na.rm = TRUE) * factor
  xr <- end(x$trend)
  freq <- frequency(x$trend)
  xr <- c(xr[1] + (xr[2] - 0.5)/freq,  xr[1] + (xr[2] + 0.5)/freq)

  panel <- function(a, b, ...) {
     lines(a, b, ...)
     ym <- mean(as.vector(b), na.rm = TRUE)
     rect(xr[1], ym + yr[1], xr[2], ym + yr[2], col = "lightgray", 
          border = gray(0.4))
     }
  
  z <- as.zoo(cbind(
       observed = x$random + if (x$type == "additive") 
                  x$trend + x$seasonal else x$trend * x$seasonal,
       trend = x$trend,
       seasonal = x$seasonal, 
       random = x$random)
       )
    
  if(is.null(ylim)) {
     ymean <- sapply(1:4, function(i) mean(coredata(z)[,i], na.rm = TRUE))
     ylim <- lapply(1:4, function(i) range(c(ymean[i] + 
                    yr, coredata(z)[,i]), na.rm = TRUE)
                   )
  }

  plot(z, main = main, panel = panel, ylim = ylim, xlab = xlab, 
       cex.lab = cex.lab, ...)
}   

decplotr <- function(x, factor = 0.95,
  main = NULL, ylim = NULL, cex.lab = 1.5, xlab = "", ...)
{
  yr <- range(x$random, na.rm = TRUE) * factor
  xr <- end(x$trend)
  freq <- frequency(x$trend)
  xr <- c(xr[1] + (xr[2] - 0.5)/freq,  xr[1] + (xr[2] + 0.5)/freq)

  panel <- function(a, b, ...) {
     lines(a, b, ...)
     ym <- mean(as.vector(b), na.rm = TRUE)
     rect(xr[1], ym + yr[1], xr[2], ym + yr[2], col = "lightgray", 
          border = gray(0.4))
   }

  serk <- vector("list",4)   
  serk[[1]] <- x$random + if (x$type == "additive") 
                  x$trend + x$seasonal else x$trend * x$seasonal
  serk[[2]] <- x$trend
  serk[[3]] <- x$seasonal
  serk[[4]] <- x$random

  z <- as.zoo(cbind(
       P1 = serk[[o[1]]],
       P2 = serk[[o[2]]],
       P3 = serk[[o[3]]],
       P4 = serk[[o[4]]])
       )
    
  if(is.null(ylim)) {
     ymean <- sapply(1:4, function(i) mean(coredata(z)[,i], na.rm = TRUE))
     ylim <- lapply(1:4, function(i) range(c(ymean[i] + 
                    yr, coredata(z)[,i]), na.rm = TRUE)
                   )
     }

  plot(z, panel = panel, ylim = ylim, xlab = xlab, main = "",
       cex.lab = cex.lab, ...)
}   

## DATA GENERATION
## INIT
nobsmin   <-  60
nobsmax   <- 120 
freqlist  <- c(1,4,12) 
lfreqlist <- length(freqlist)

yearmin  <- 1958
yearmax  <- 2007
nyx   <- yearmax - yearmin 

eps <- 0.001
modnum  <- c(1:6)
modsel  <- c(0*1:4)
slabel <- c(1:4)
namsel  <- c(1:20)
dim(namsel) <- c(4,5)
qtext   <- c("zeigt die beobachtete Reihe. ",     
             "gibt den mittelfristigen Verlauf der Reihe wieder (Trend).",
             "macht das sich wiederholende Saisonmuster sichtbar.", 
             "weist die irregul\\\\\"are Komponente aus. ")

wh <- sample(1:4, 4)
wh2 <- sample(1:4, 4)
if (sum(wh == wh2) > 1) {
  wh[5] <- sample(1:4, 1)
  wh2[5] <- sample(1:4, 1)
}else {
  wh[5] <- wh2[5] <- sample(1:4, 1)
}
q5 <- which(wh[1:4] == wh[5])

ifreq <- ceiling( runif(1,min=2-1+eps,max=lfreqlist-eps) )
freq  <- freqlist[ifreq]
nobs  <- ceiling( runif(1,min=nobsmin-1+eps,max=nobsmax-eps) )
nyears <- floor(nobs / freq)
if (freq == 4)  { if (nyears > 10) {nyears = 10} }
if (freq == 12) { if (nyears > 8) {nyears = 8} }
nobs  <- nyears*freq
## WITH SEASON -- h
if (runif(1) > 0.5) {
  seas <- exams:::f_seas(nobs,freq)
  hs   <- exams:::f_h(nobs,seas=seas)

  if (nyears > nyx) { 
    ts.hs <- ts(hs,start=1) 
    ts.t  <- ts( rep(mean(ts.hs), times=nobs) , start=1 )
  } else { 
    yhh <- nyx - nyears
    ybeg <- ceiling( runif(1,min=0-1+eps,max=yhh-eps) ) 
    ybeg <- ybeg + yearmin
    ts.hs <- ts(hs,start=ybeg,freq=freq) 
    ts.t <- ts( rep(mean(ts.hs), times=nobs) , start=ybeg,freq=freq )
  }
  series <- ts.hs
} else {
## WITH SEASON -- linear trend
  seas <- exams:::f_seas(nobs,freq)
  hs   <- exams:::f_hg(nobs,seas=seas,scal=3.0)
  lts  <- exams:::f_lt(nobs,resid=hs);
  
  if (nyears > nyx) { 
    ts.lts <- ts(lts,start=1)
    ts.t <- ts( c(1:nobs) , start=1 )
  }else { 
    yhh <- nyx - nyears
    ybeg <- ceiling( runif(1,min=0-1+eps,max=yhh-eps) ) 
    ybeg <- ybeg + yearmin
    ts.lts <- ts(lts,start=ybeg,freq=freq) 
    ts.t <- ts( c(1:nobs) , start=ybeg,freq=freq )
  }
  series <- ts.lts
}

## QUESTION/ANSWER GENERATION
questions    <- paste("Der Plot P", c(1:4, q5), " ", qtext[wh2], sep = "")
solutions    <- wh == wh2
explanations <- paste("Der Plot P", c(1:4, q5), " ", qtext[wh], sep = "")

o <- sample(1:5)
questions <- questions[o]
solutions <- solutions[o]
explanations <- explanations[o]

dec <- decompose(series)
solc[1] <- "beobachtete Reihe: Sie setzte sich additiv aus den 3 Komponenten - 
   Trend, Saisonmuster und irregul\\\\\"arer Komponente zusammen."
solc[2] <- "Trend: Hier wird die mittel- bis langfristige Entwicklung ohne 
Saison oder irregul\\\\\"arer Effekte dargestellt."
solc[3] <- "saisonale Komponente: Sie gibt den Rhythmus 
der saisonalen Schwankungen wieder."
solc[4] <- "irregul\\\\\"are Komponente: Hier werden die Ausschl\\\\\"age der Reihe angezeigt, 
  die weder der Saison, noch der mittelfristigen Entwicklung zugeordnet werden 
  k\\\\\"onnen."

o <- wh[1:4]
solc <- solc[o]
@

\begin{question} 
  Es wurde aus der Gruppe der additiven Modelle (horizontales Muster,
  linearer Trend, lokaler Trend) mit Saison zuf\"allig eines
  ausgew\"ahlt, eine Zeitreihe dazu erzeugt und deren Zerlegung in
  Trend, Saison und irregul\"are Komponente berechnet. Diese drei
  Komponenten zusammen mit der Originalreihe sind in
  Abbildung~\ref{fig:ch11-02}---allerdings in einer {\it zuf\"alligen
    Anordnung}---geplottet.
  
  Aufgabe ist es den Plots die korrekte Bezeichnung zuzuordnen.

\begin{figure}[htb!]
\begin{center}
<<fig=TRUE, height = 5.5, width = 7, echo=FALSE, eps=FALSE, results=hide>>=
decplotr(dec, oma = rep(0, 4))
@
\end{center}
\caption{Zuf\"allige Anordnung der Zeitreihenkomponenten}\label{fig:ch11-02}
\end{figure}

Welche der folgenden Aussagen sind richtig? 
\emph{(Anmerkung: Die Aussagen sind entweder ungef\"ahr richtig oder deutlich falsch.)}
\begin{itemize}
  \item[(a)] \Sexpr{questions[1]} 
  \item[(b)] \Sexpr{questions[2]}
  \item[(c)] \Sexpr{questions[3]}
  \item[(d)] \Sexpr{questions[4]}    
  \item[(e)] \Sexpr{questions[5]}
\end{itemize}
\end{question}

%% SOLUTIONS
\begin{solution}
  
  In einem ersten Schritt wird bestimmt, welcher Plot welchen Teil der
  Zerlegung darstellt:
\begin{itemize} 
  \item[] Plot 1, P1, \Sexpr{solc[1]}
  \item[] Plot 2, P2, \Sexpr{solc[2]}
  \item[] Plot 3, P3, \Sexpr{solc[3]}
  \item[] Plot 4, P4, \Sexpr{solc[4]}
\end{itemize}

Die Plots in der richtigen Anordnung sind in
Abbildung~\ref{fig:ch11-02a} gegeben.

\begin{figure}[htb!]
\begin{center}
<<fig=TRUE, height = 5.5, width = 7, echo=FALSE, eps=FALSE, results=hide>>=
decplot(dec, oma = rep(0, 4), main = "")
@
\end{center}
\caption{Zerlegung der Zeitreihe in additive Komponenten}\label{fig:ch11-02a}
\end{figure}

Damit lassen sich nun obige Aussagen als richtig oder falsch bewerten.
\begin{itemize}
  \item[(a)] \Sexpr{mchoice2tex(solutions[1])}: \Sexpr{explanations[1]}
  \item[(b)] \Sexpr{mchoice2tex(solutions[2])}: \Sexpr{explanations[2]}
  \item[(c)] \Sexpr{mchoice2tex(solutions[3])}: \Sexpr{explanations[3]}
  \item[(d)] \Sexpr{mchoice2tex(solutions[4])}: \Sexpr{explanations[4]}
  \item[(e)] \Sexpr{mchoice2tex(solutions[5])}: \Sexpr{explanations[5]}
\end{itemize}
\end{solution}

%% META-INFORMATION
%% \extype{mchoice}
%% \exsolution{\Sexpr{mchoice2string(solutions)}}
%% \exname{Mehrfachantworten}


